## x400

### OSI Model
In oder for computers to be able to talk to one another, they need tp speak the same language. Due to the million different reasons that computers need to talk to each other there are another million protocols to somewhat uniformly control how the communications traverse across networks. 

In order to make this more modular the OSI model was created as a conceptual model for these standards to adhere to in order to facilitate information flow. This model is made of 7 layers as follows:
1. **Physical Layer** - Deals with transmitting a raw bit stream over a physical medium (turning something like light or electricity into data).  
   - Devices at this layer include cables like coax and fiber, but can also be frequencies and EM pulses for wireless communications  
2. **Data Link Layer** - Deals with transferring data from one device to another in frames within a broadcast domain. Error checking and flow control are added at this layer to make dataflow practical in modern application (focuses on getting information from one device to its neighbor). 
   - Devices at this layer include switches. 
3. **Networking Layer** - Deals with connecting broadcast domains to one another to facilitate wide area networks (makes big networks out of smaller networks).
   - Devices at this layer include routers  
4. **Transport Layer** - deals with enabling reliable networks, ensures complete data transfers and provides additions such as volume and rate control (helps data move more efficiently). 
5. **Session Layer** - Deals with maintaining sessions between networked applications (controls the conversation). 
6. **Presentation Layer** - responsible for ensuring the data is presented in a usable format, also where encryption happens
7. **Application Layer** - Allows applications to access networked services. 
When your data is moved over the internet, layers 1-3 facilitate actually getting your data from point a to point b. Layers 4-7 enable the underlying communication between the computers to occur in a uniform fashion.   
### Sockets
#### Key concepts/definitions to know
- **Sockets** - the pairing of an IP address with a Port, or otherwise a connection endpoint. This happens at layer 5 although it influences the structure of layer 4. 
- There are two kinds of sockets
  - Stream Sockets: Used for TCP
  - Datagram Sockets: Used for TCP
- A socket behaves a lot like a file descriptor, and can be interacted with using ```read()```  and ```write()``` a function to create a socket fd looks like this:
  - ```
    socket(int domain, int type, int protocol)
    ```
    - ```domain``` - protocol family of the socket (ex: ```pf_inet, pf_ax25```)
    - ```type``` - type of socket (ex: ```sock_stream, sock_dgram```)
    - ```protocol``` - choose a protocol within the family (most families only have 1 so this is usually set to ```0```)
- **Connecting** sockets is done via pairing the descriptor created in the function above with a remote host. The function to do so looks like this:
  - ```
     connect(int fd, struct sockaddr *remote_host, socklen_t addr_length) 
    ```
    *Note: ```socklen_t``` is a data type for an unsigned 32bit int for a network address*
-  **Binding** sockets is done via pairing a sockets with a local address in order to listen to connections. The function looks like this:
   -  ```
        bind(int fd, struct sockaddr *local_addr, socklen_t addr_length)
      ``` 
    - To **listen** for connections you must use the following function, which ques requests up to ```backlog_queue_size```
      - ```
          listen(int fd, int backlog_queue_size)
        ```
    - To **accept** a connectiona bound socket must be paired with a remote host as well as the size off the address structture 
      - ```
          accept(int fd, sockaddr *remote_host, socklen_t *addr_length)
        ```
  - Sending and recieving are done via similar functions using the socket fd where ```n``` is the number of bytes sent or recieved
    - ```
      send(int fd, void *buffer, size_t n, int flags)
      recv(int fd, void *buffer, size_t n, int flags)
      ```
    
  - All of these functions should return a ```-1``` if an error occurs which can be used in an if statement for error checking if the output is ```== -1```
  - Many of these functions reference a ```sockaddr``` struct. This struct contains the infomration necessary to define a host given that there are many different ways a single host can be addressed depending on the protocol
     - ```SOCKADDR_COMMON``` is an unsigned int used to represent the family of addresses along with the rest of the strcture for its saved data .
     - These different sockaddr structures are all the same size allowing for them to be typecasted into one another. 
#### AF_INET
- ```AF_INET``` is the address family under the ```PF_INET``` protocol family, Together this pair reporesent IPv4. THe address structure shown in the ```netinet/in.h``` file is as shown
  - ```
      /* Structure describing an Internet socket address.  */
      struct sockaddr_in
        {
          __SOCKADDR_COMMON (sin_);
          in_port_t sin_port;     /* Port number.  */
          struct in_addr sin_addr;    /* Internet address.  */

          /* Pad to size of 'struct sockaddr'.  */
          unsigned char sin_zero[sizeof (struct sockaddr) -
              __SOCKADDR_COMMON_SIZE -
              sizeof (in_port_t) -
              sizeof (struct in_addr)];
         };
    ```
    ![struct](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781593271442/files/httpatomoreillycomsourcenostarchimages254410.png.jpg)
    - ```SOCKADDR_COMMON``` in this context defines our address family (IPv4)
    - Next is the port which is a 16 bit short between 0-FFFF
    - next is a 32 bit IP address
    - Lastly, 8 bits pad out the rest of the address
      - *Note: The host and network addresses in this struct are expected to be in big endian order regardless of architecture so there are translation functions to ensure this is done as such*
        - ```htonl(long value)``` - Host-to-Network Long
        - ``` ntohl(long value)``` - Network-to-Host Long
    - Since these structs are a bit different from the simple IP addresses we use there are a couple different functions that deal with translation of an ascii string representation of an IP address to an in_addr struct they are.
      -  ```inet_aton(char *ascii_addr, struct in_addr *network_addr)```
      -  ```inet_ntoa(struct in_addr *network_addr)```

### Traffic Headers
Traffic must movr in a uniform manner to ensure that it is properly handled over the internet which necessitates standards for routable traffic. Traffic at the lower layers by nature is unencrypted to facilitate transportation from one endpoint to another and because of so we can take a look at what these headers look like and what role they play in ensuring data is transported over the internet. Since each layer plays a distinct part, we'll split this up by layer. 

#### Physical
Hopefully you never have to deal with anythinh this low on the totem pole, but layer 1 and 2 co-inside with one another and this field is often overlooked because its to small and nice, but at later 1 there are two important things in a frme.
  - **Preamble** - The preamble is a 7 octes (56 bits) pattern of 1s and 0s that allows networked devices to syncronoze their recivever clocks allowing bit-level syncronization. 
  - **Start Frame Delimiter** - An 8 bit value that marks the end of the preamble and th begninning of the layer 2 frame. 
Since Physical layer Tranciever circuityu is required to connect the MAC to a physical medium (your NIC) a bus from the media independent interface family is required to define the structure of your function preamble. Different chips use different busses (F/E uses MII, but GbE uses GMII). 
#### Data Link
This are the traditional frames youre used to looking at if youre looking at LAN traffic. At the layer 2 level, the ethernet frame is a small header composed of a few minor parts to pass traffic to neighbors. 
  - **Header** - The header is composed of the source and destination MAC addresses of the frame in question. Optionally this can contain a 802.1Q or 802.1ad (VLAN) tags.
    - The EtherType field is normally used to display the size of the payload, but in a sitaiton in which the payload is over 1536, this field will be used to display the ptotocol encapsulated by the frame and in that case the length will be placed in the interpacket gap
  - **Payload** - A variable length field which contains headers and data for higher layers
  - **Frame Check Sequence** - a value computed as a function of the device MAC adresses, provides error checking. 

![Ethernet](https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Ethernet_frame.svg/1920px-Ethernet_frame.svg.png) 

#### Network
At this layer, the data is placed into packets and these packets, of course have a multitude of fields centered around getting data from a source address to a destination address in another network. 

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             Note that one tick mark represents one bit position.

```
*Source [RFC791](https://www.rfc-editor.org/rfc/rfc791)*

While there are a lot of fields in this address I will point out ones of particular importance
- **Source/Desttination Address** - On the internet, This field contains the first publicly routable IP address (usually your gateway) with that of the destination server or device in question
- **TTL** - This displays the number of "Hops" or devices that this packet can traverse before it disappears (used to prevent infinitely lost packets from cluttering the internet) every time a packet hits a new device this number is decremented
- **Flags** - mainly used to specify if a packet will be frangmented or not
- **Fragment offset** - used to help put large packets that have been fragmented back together again

#### Transport
THe transport layer also has a multitude of fields, this time centered around ports and synchronization numbers. This layer is used to ensure reliable communication over the internet.
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |       |C|E|U|A|P|R|S|F|                               |
   | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
   |       |       |R|E|G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           [Options]                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               :
   :                             Data                              :
   :                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

          Note that one tick mark represents one bit position.
```
*Source: [RFC9293](https://www.rfc-editor.org/rfc/rfc9293)*

While there are many fields here, the most important are
- **Sequence/Acknowledgement Numbers** - These numbers are used betweent he client and the server in a two way comunication to synchronize the flow of communication and ensure no packets are lost within a conversation. They will change throughgout the conversation as a result of the volume of traffic sent.
- **Flags** - TCP has various flags to use as a form of flow control. Ther are as follows
  - <details>

    <table class="tg">
    <thead>
      <tr>
        <th class="tg-uzvj">TCP flag</th>
        <th class="tg-wa1i">Meaning</th>
        <th class="tg-wa1i">Purpose</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td class="tg-cly1">URG</td>
        <td class="tg-cly1">Urgent</td>
        <td class="tg-cly1">Identifies important data</td>
      </tr>
      <tr>
        <td class="tg-cly1">ACK</td>
        <td class="tg-cly1">Acknowledgment</td>
        <td class="tg-cly1">Acknowledges a packet; it is turned on for the majority of the connection</td>
      </tr>
      <tr>
        <td class="tg-cly1">PSH</td>
        <td class="tg-cly1">Push</td>
        <td class="tg-cly1">Tells the receiver to push the data through instead of buffering it</td>
      </tr>
      <tr>
        <td class="tg-cly1">RST</td>
        <td class="tg-cly1">Reset</td>
        <td class="tg-cly1">Resets a connection</td>
      </tr>
      <tr>
        <td class="tg-cly1">SYN</td>
        <td class="tg-cly1">Synchronize</td>
        <td class="tg-cly1">Synchronizes sequence numbers at the beginning of a connection</td>
      </tr>
      <tr>
        <td class="tg-cly1">FIN</td>
        <td class="tg-cly1">Finish</td>
        <td class="tg-cly1">Gracefully closes a connection when both sides say goodbye</td>
      </tr>
    </tbody>
    </table>
   </details>

### Network Sniffing
#### Definitions/Concepts to know
- In an unswitched network data is delivered to all devices regardless of intent, this is patched in switched networks
  - Even in a switched network, you can sniff traffic not meant for you by going into promiscuous mode.
- ```tcpdump``` - A command line utility used to sniff traffic
- ```dsniff``` - sniffer specifically designed to look for user/pass
- **Raw Sockets** - provides direct access to lower level protocols and data must be explicitly handled by the program.
  - specified by ```SOCK_RAW```
  - programs that handle raw sockets need root permissions.
- ```Nemesis``` is a command line utility used to spoof network traffic
  - Nemesis typically does single commands for requests, but it can be combined with some bash scripting to send bogus arp requests every 10s
    ```
      reader@hacking:~/booksrc $ while true
      > do
      > sudo nemesis arp -v -r -d eth0 -S 192.168.0.1 -D 192.168.0.118 -h
      00:00:AD:D1:C7:ED -m 00:C0:F0:79:3D:30 -H 00:00:AD:D1:C7:ED -M 
      00:C0:F0:79:3D:30
      > sudo nemesis arp -v -r -d eth0 -S 192.168.0.118 -D 192.168.0.1 -h 
      00:00:AD:D1:C7:ED -m 00:50:18:00:0F:01 -H 00:00:AD:D1:C7:ED -M 
      00:50:18:00:0F:01
      > echo "Redirecting..."
      > sleep 10
      > done
      ```

### Attacks
#### Definitions/Concepts to know
- **ARP Poisoning** is a man in the middle style attack that takes advantage of the fact that ARP requests, used to pair IP addresses with MACs, are stateless and machines accept replies without valid requests
- **SYN FLood** exhausts the connection states of a device by attempting to open a bunch of TCP connections without sending any information
  - This is prevented in linux via SYN cookies, which adjust initial ack numbers with info based on gost details, the connections dont become active unless the final ack is checked. This is done because ack packets require actual info to be sent.    
- **Ping of Death** occurs because the max ICMP echo size was 65538 bytes and people would purposefully send packets larger than this to crash systems. 
- **Teardrop** exploits a vulnerability in TCP fragmentation in which the numbers are supposed to reassemble packets with no overlap, if overlap occured it could cause programs to crash.
- **Amplification attacks** take advantage of broadcast domains by pinging the broadcast address with the spoofed IP of the victim causing all devices in the domain to reply to the request to the victim. 
- **TCP/IP Hijacking** - grabs the sequence and acknowledgement numbers from a legitimate connection (usually something that uses one time passwords) and spoofs its IP address along with the proper sequence and acknowledgement numbers for a man on the side style attack
